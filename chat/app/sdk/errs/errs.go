package errs

import (
	"encoding/json"
	"errors"
	"fmt"
	"runtime"
)

// ErrCode represent the code of err
type ErrCode struct {
	value int
}

// Value returns the integer value of the error code.
func (ec ErrCode) Value() int {
	return ec.value
}

// String returns the string representation of the error code.
func (ec ErrCode) String() string {
	return codeNames[ec]
}

// json.Marshaler
// Marshaler is the interface implemented by types that
// can marshal themselves into valid JSON.
//
//	type Marshaler interface {
//		MarshalJSON() ([]byte, error)
//	}
//type TextMarshaler interface {
// 	MarshalText() (text []byte, err error)
// }
// TextMarshaler is the interface implemented by an object that can marshal itself into a textual form.
// MarshalText encodes the receiver into UTF-8-encoded text and returns the result.

// MarshalText func; implementation of the marsha interface for JSON conversion
func (ec ErrCode) MarshalText() ([]byte, error) {
	return []byte(ec.String()), nil
}

// type TextUnmarshaler Â¶
// type TextUnmarshaler interface {
// 	UnmarshalText(text []byte) error
// }
// TextUnmarshaler is the interface implemented by an object that can unmarshal a textual representation of itself.

// UnmarshalText must be able to decode the form generated by MarshalText. UnmarshalText must copy the text if it wishes to retain the text after returning.
// i give it text err it will change the value of the errcode to represent this error message
func (ec *ErrCode) UnmarshalText(text []byte) error {
	errName := string(text)
	v, exist := codeNumbers[errName]
	if !exist {
		return fmt.Errorf("err code %q does not exist", errName)
	}
	*ec = v
	return nil
}

func (ec ErrCode) Equal(ec2 ErrCode) bool {
	return ec2.value == ec.value
}

// Error represent error in the system

type Error struct {
	Code     ErrCode `json:"code"`
	Message  string  `json:"message"`
	FuncName string  `json:"-"` //represent the function name where error occured this field is ignored
	FileName string  `json:"-"` // represent the file name where error occured
}

func (e *Error) Encode() ([]byte, string, error) {
	data, err := json.Marshal(e)
	return data, "application/json", err
}

// Error implement error interface
func (e *Error) Error() string {
	return e.Message
}

// Equal provides support for the go-cmp package and testing.
func (e *Error) Equal(e2 *Error) bool {

	return e.Code == e2.Code && e.Message == e2.Message
}

func New(code ErrCode, err error) *Error {
	// now how to get the function name and the file where error occured
	pc, file, line, _ := runtime.Caller(1)
	return &Error{
		Code:     code,
		Message:  err.Error(),
		FileName: fmt.Sprintf("%s:%d", file, line),
		FuncName: runtime.FuncForPC(pc).Name(),
	}
}

// Newf construct an error based on a formated error message
func Newf(code ErrCode, format string, values ...any) *Error {

	pc, file, line, _ := runtime.Caller(1)
	return &Error{
		Code:     code,
		Message:  fmt.Sprintf(format, values...), // why not putting only values
		FileName: fmt.Sprintf("%s:%d", file, line),
		FuncName: runtime.FuncForPC(pc).Name(),
	}
}

// NewError checks for an Error in the error interface value. If it doesn't
// exist, will create one from the error.
func NewError(err error) *Error {
	var errsErr *Error
	if errors.As(err, &errsErr) {
		return errsErr
	}
	return New(Internal, err)
}
